class ThreadMultiNoSleepDemo {
    public static void main(String[] args) {
        Runnable task1 = () -> {    // 20 미만 짝수 출력
            for(int i = 0; i < 20; i++) {
                if(i % 2 == 0)
                    System.out.print(i + " ");
            }          
        };

        Runnable task2 = () -> {    // 20 미만 홀수 출력
            for(int i = 0; i < 20; i++) {
                if(i % 2 == 1)
                    System.out.print(i + " ");
            } 
        };

        Thread t1 = new Thread(task1);
        Thread t2 = new Thread(task2);

        t1.start();
        t2.start();
    }
}

/*
// 3번의 실행결과
1 3 5 0 2 4 6 8 10 12 14 7 16 9 11 13 15 17 19 18 

1 3 5 0 2 7 4 9 6 8 10 12 14 11 13 15 17 16 18 19 

1 3 0 5 2 4 6 7 8 10 12 14 16 9 11 13 15 18 17 19 

*/

/*
	세 번의 실행 결과를 보였는데 세 번 모두 실행 결과가 다르다. 하지만 이것이 쓰레드의 실행 특성이다.
	각각의 쓰레드는 이렇듯 독립적으로 자신의 일을 실행해 나간다.
	
	쓰레드가 코어의 수보다 많이 생성된다면,
	CPU의 코어가 하나이던 시절의 멀티 쓰레드 프로그래밍에는 다음과 같은 장점이 있었다.
	* CPU의 코어가 둘 이상인 것과 같은 효과를 보였다.
	* 하나의 코어가 둘 이상의 쓰레드를 담당하므로 코어의 활용도가 높았다.
	
	코어가 하나이고 쓰레드가 둘 이상이면 이들은 코어를 나누어 차지하며 실행을 이어 나간다. 그런데
	그 나누는 시간의 조각이 매우 작기 때문에 동시에 실행되는 효과를 충분히 누릴 수 있었다. (그만큼
	코어가 쉬는 시간을 최소화할 수 있어서 코어의 활용도도 높았다.) 마찬가지로 멀티 코어 CPU
	기반에서도 코어의 수보다 많은 수의 쓰레드가 생성되면 쓰레드들은 코어를 나누어 차지하게 된다. 
	물론 나누는 시간의 조각이 매우 작기 때문에 프로그램 사용자는 이러한 사실을 눈치채지 못한다.
*/