1. 프로그램의 실행요청은 컴퓨터 사용자에 의해 이뤄지지만, 실질적인 프로그램의 실행은 ( 운영체제 )에 의해서 이뤄진다.

2. 프로그램의 실행이 요청 되면, 다음의 형태로 메모리 공간이 할당된다. 
메모리에 대해 서술하시오.

프로세스에 할당된 메모리.

이렇듯 할당된 메모리 공간을 기반으로 실행 중에 있는 프로그램을 가리켜 	(    )라 한다.
따라서 (    )를 간단히 '실행중인 프로그램'으로 설명하기도 한다.


3. 하나의 프로세스에 둘 이상의 쓰레드를 실행시키자.
그리고 각각의 쓰레드 이름에 "멋진 쓰레드", 와 "예쁜 쓰레드"라는 이름을 주고 반복을 100번을 시키자

쓰레드의 우선순위를 가져오는 메소드? 
쓰레드의 우선순위를 설정하는 메소드? 
쓰레드의 우선순위를 설정할 때 쓰는 상수는? 
Thread.MAX_PRIORITY	10
Thread.NORM_PRIORITY	5
Thread.MIN_PRIORITY	1

쓰레드의 라이프 사이클(Life Cycle)은?


	New ------------ (start 메소드 호출 시)
			| 
			V
			Runnable   	------------------> Blocked
			|		<------------------
			|		(스케쥴러는 Runnable 상태의 쓰레드 중
	Dead <----------- 		 하나를 선택해 실행)
	      (run 메소드 완료 시)

쓰레드가 생성되면 위 그림이 보여주는 네 가지 상태 중 한가지 상태에 있게 된다. 
각각의 상태에 놓이는 시점과 상태가 변경되는 시점을 정리하면 다음과 같다.

* New 상태
쓰레드 클래스가 키워드 new를 통해서 인스턴스화 된 상태를 가리켜 'New 상태'라 한다. 
이 상태에서는 자바 가상머신에 의해 관리가 되는 쓰레드의 상태는 아니다. 
즉 운영체제 입장에서는 쓰레드라 부르기에는 이른 감이 있는 상태다. 그러나 자바에서는 이 상태에서부터 쓰레드라 표현한다.

*Runnable 상태
쓰레드 인스턴스를 대상으로 start 메소드가 호출되면, 해당 쓰레드는 비로소 'Runnable 상태'가 된다. 
이는 모든 실행의 준비를 마치고, 스케줄러에 의해서 선택되어 실행될 수 있기만을 기다리는 상태이다. 
이로써 우리는 start 메소드가 호출된다고 해서 바로 run 메소드가 호출되는 것이 아님을 알 수 있다. 
Runnable 상태에 있다가, 스케줄러에 의해서 실행의 대상으로 선택이 되어야 비로소 run 메소드가 처음 호출이 된다.

*Blocked 상태
실행 중인 쓰레드가 sleep, 또는 join 메소드를 호출하건, CPU의 할당이 필요치 않는 입출력 연산을 하게 되면, 
CPU를 다른 쓰레드에게 양보하고, 본인은 'Blocked 상태'가 된다. Blocked 상태에서는 스케줄러의 선택을 받을 수 없다. 
다시 스케줄러의 선택을 받아서 실행이 되려면, Blcoked 상태에 놓이게 된 원인이 제거되어서, 
Runnable 상태로 돌아와야 한다. 입출력 작업으로 인해서 Blocked 상태가 되었다면, 
입출력 작업이 완료되면서 Runnable 상태가 된다. 그리고 sleep 메소드의 호출로 인해서 
Blocked 상태가 되었다면, sleep 메소드가 반환이 되면서 다시 Runnable 상태가 된다.

*Dead 상태
run 메소드의 실행이 완료되어서 run 메소드를 빠져 나오게 되면, 해당 쓰레드는 'Dead 상태'가 된다. 
그리고 이 상태는 쓰레드의 실행을 위해서 할당 받았던 메모리를 비롯해서 
각종 쓰레드 관련 정보가 완전히 사라지는 상태이다. 
참고로 한번 Dead 상태가 된 쓰레드는 다시 Runnable 상태가 되지 못한다. 
쓰레드의 실행을 위해 필요한 모든 것이 소멸되기 때문이다.


쓰레드의 메모리 구성

쓰레드가 생성되면 가상머신은 쓰레드의 실행을 위한 별도의 메모리 공간을 할당한다. 
그렇다면 이러한 별도의 메모리 공간은 정확히 무엇을 의미하는 것일까?
쓰레드의 가장 큰 역할은 별도의 실행흐름 형성이다. 
그리고 별도의 실행흐름은 메소드의 호출을 통해서 형성된다. 
즉 처음에는 run 메소드가 호출되고, run 메소드 내에서는 또 다른 메소드를 호출하면서 
main 메소드와는 다른 흐름을 형성한다. 이렇듯 main 메소드와는 전혀 다른 실행흐름을 형성하기 위해서는 
별도의 스택이 쓰레드에게 할당되어야 한다. 
따라서 main 쓰레드 이외에 두 개의 쓰레드가 추가로 생성되면, 가상머신은 다음의 형태로 메모리를 구성한다.



		공유			공유
메소드 영역  ----------> 메소드 영역 <---------- 메소드 영역


					
스택 영역  		 스택 영역 		 스택 영역


		공유			공유
힙 영역      ---------->   힙 영역   <---------- 힙 영역

A 쓰레드		main 쓰레드		B 쓰레드


	쓰레드에 할당되는 메모리

위 그림에서 보이듯이 모든 쓰레드는 자신의 스택을 할당 받는다. 
그러나 힙과 메소드 영역은 모든 쓰레드가 공유한다. 
여기서 특히 힙이 공유됨에 주목하자. 힙 영역이 공유된다는 것은 
모든 쓰레드가 동일한 힙 영역에 접근이 가능함을 의미하는 것이고, 이는 다음과 같은 일이 가능함을 의미하는 것이다.
"A 쓰레드가 만든 인스턴스의 참조 값(사실상 주소 값)만 알면 B 쓰레드도 A 쓰레드가 만든 인스턴스에 접근 가능하다."
그래서 쓰레드 사이에 데이터를 주고받아야 할 때에는(쓰레드간 통신이 필요할 때에는) 힙 영역을 활용한다.

참고:
쓰레드 인스턴스를 생성하고 나서, start 메소드를 호출하면 run 메소드가 실행되는데, run 메소드를 직접 호출하면 안되나?
run 메소드를 직접 호출하는 것도 불가능한 일은 아니다. 
단 이러한 경우에는 단순한 메소드의 호출일뿐, 쓰레드의 생성으로 이어지지는 않는다. 
쓰레드는 자신만의 메모리 공간을 할당 받아서 별도의 실행 흐름을 형성한다. 
따라서 자바 가상머신은 start 메소드의 호출을 요구하는 것이다. 
메모리 공간의 할당 등 쓰레드의 실행을 위한 기반을 마련한 다음에 run 메소드를 대신 호출해 주기 위해서 말이다. 
이는 우리가 main 메소드를 직접 호출하지 않는 것과 비슷한 이치이다.

CPU가 하나인데, 어떻게 둘 이상의 쓰레드가 동시에 실행 가능한가?
이 질문에 대한 답변은 생각보다 간단하다. 모든 쓰레드는 CPU를 공유한다. 
물론 CPU를 공유하는 방식에는 원칙이 존재한다. 참고로 코어(CPU 내에 존재하는 연산장치)가 
여러 개 존재하는 CPU에서는 쓰레드 각각에 코어가 하나씩 할당되어 실행되기도 한다.

main 메소드가 종료되어도 쓰레드는 실행을 계속하나? 그리고 쓰레드는 run 메소드의 실행이 완료되면 종료되나?
쓰레드의 main 메소드가 run 메소드이다. 따라서 run 메소드의 실행이 완료되면, 
해당 스레드는 종료가 되고 소멸된다. 그리고 앞서 보인 예제에서는 main 메소드 내에서 쓰레드를 생성했었다. 
그런데 쓰레드를 생성하고, start 메소드를 호출한다고 해서, 
main 메소드가 멈춰서는 것은 아니다. main 메소드도 여느 쓰레드와 마찬가지로 자신만의 실행흐름을 이어간다. 
따라서 main 메소드가 먼저 종료될 수도 있다. 하지만 main 메소드가 종료되어도 실행 중에 있는 쓰레드가 있다면, 
프로그램은 종료되지 않는다. 사실 main 메소드도 쓰레드에 의해 실행된다. 
그리고 main 메소드를 실행하는 쓰레드를 가리켜 별도로 'main 쓰레드'라 부르기도 한다. 
결국 마지막 남은 쓰레드까지 실행을 완료해야 프로그램은 종료된다.

쓰레드가 별도의 실행흐름을 구성하는 것은 알겠는데, 
그렇다면 정확히 무엇을 가리켜 쓰레드라 하나? 인스턴스가 쓰레드인가?
Thread를 상속하는 클래스의 인스턴스를 가리켜 쓰레드라고도 하지만, 
이는 엄밀히 말해서 잘못된 표현이다. 쓰레드는 자바 가상머신이 생성하는 것이기 때문이다. 
start 메소드가 호출되면, 자바 가상머신은 별도의 실행흐름을 형성하기 위한 여러 가지 준비에 들어간다. 
그 중 대표적인 것은 메모리 공간의 할당이다. 
실행흐름을 구성하기 위해서는 메모리 공간의 할당이 필수 아니겠는가? 
그리고 이미 생성된 쓰레드들과 CPU를 나눠 쓰기 위한 각종 정보들이 등록된다. 
이렇듯 별도의 실행흐름을 형성하기 위해서 자바 가상머신에 의해 만들어지는(또는 준비되는) 
모든 리소스와 각종 정보들을 총칭해서 쓰레드라 한다.

4. class Sum 이 있고 여기에는 숫자를 저장할 수 있는 Instance 변수와 숫자를 더하는 메소드 숫자를 반환하는 메소드가 있다
class AddThread 라는 클래스를 쓰레드를 돌리기 위해서 인터페이스를 구현해서 두 개의 숫자 인스턴스 변수와
이 두개의 숫자 인스턴스 변수를 시작 값부터 끝 값까지 더하도록 메소드를 만들자. 그리고 AddThread 클래스는 Sum을 상속받도록 하자.
그리고 메인메소드에서 쓰레드를 두 개 생성해서 하나는 1부터 50까지 더하고 하나는 51부터 100까지 더해서 두 개의 쓰레드 실행결과 그 더한 값을 출력하도록 하자.

5. 해당 쓰레드가 종료될 때까지 실행을 멈출 때 호출하는 메소드는? join()

