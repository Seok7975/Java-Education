1. 프로그램의 실행요청은 컴퓨터 사용자에 의해 이뤄지지만, 실질적인 프로그램의 실행은 (운영체제)에 의해서 이뤄진다.

2. 프로그램의 실행이 요청 되면, 다음의 형태로 메모리 공간이 할당된다.

	----------------------------------------	
	|					|	
	|	------------------------	|		
	|	|			|	|			
	|	|	메소드 영역	|	|			
	|	|			|	|
	|	------------------------	|		
	|					|
	|					|
	|					|	
	|	------------------------	|		
	|	|			|	|			
	|	|	스택 영역	|	|			
	|	|			|	|
	|	------------------------	|		
	|					|
	|					|
	|					|	
	|	------------------------	|		
	|	|			|	|			
	|	|	힙 영역		|	|			
	|	|			|	|
	|	------------------------	|		
	|					|
	|---------------------------------------|

프로세스에 할당된 메모리.

이렇듯 할당된 메모리 공간을 기반으로 실행 중에 있는 프로그램을 가리켜 	('프로세스(Process)')라 한다.
따라서 프로세스를 간단히 '실행중인 프로그램'으로 설명하기도 한다. 그런데 지금까지 우리가 보아왔던 프로세스들은 프로그램의 흐름을 하나만 형성하고 있었다. main 메소드의 호출을 통해서 하나의 흐름이 형성되었으며, main 메소드의 실행이 완료되면 흐름도 종료가 되었다.
그러나 하나의 프로세스 내에서 둘 이상의 프로그램 흐름을 형성할 수도 있다. 쓰레드라는 것이 프로세스 내에서 프로그램의 흐름을 형성하는 주체인데, 하나의 프로세스 내에 둘 이상의 쓰레드가 존재할 수 있기 때문이다.

자바 가상 머신은 운영체제 위에서 동작하므로, 다른 응용 프로그램과 같이 운영체제에 의해 메모리 공간(RAM)을 할당받아 동작한다. 자바는 이 할당받은 메모리 공간을 효율적으로 사용하기 위해 3가지로 구분한다.

1. 메소드 영역(메소드의 바이트 코드, static 변수)
클래스의 바이트코드(JVM에 의해 실행 가능한 코드)가 로딩되는 메모리 공간, 인스턴스를 만들거나 클래스 멤버의 접근을 위해서는 어딘가에 클래스의 정보가 저장되어야 하는데, 그 영역이 메소드 영역인 것.

2. 스택 영역(지역변수, 매개변수)
중괄호 내에 할당된 이후에 해당 중괄호를 벗어나면 바로 소멸되는 특성의 데이터 저장을 위한 영역. 지역변수와 매개변수는 선언되는 순간에 스택에 할당되었다가 자신이 할당된 영역을 벗어나면 소멸이 된다.

3. 힙영역(인스턴스)
인스턴스의 소멸시점 및 소멸 방법이 지역변수와 다르기 때문에 별도의 공간에 할당되는데, 인스턴스의 참조변수는 메소드 내에 있기 때문에 지역변수이지만 참조변수가 가리키는 인스턴스는 힙영역에 저장되는 것.

3. 하나의 프로세스에 둘 이상의 쓰레드를 실행시키자.
그리고 각각의 쓰레드 이름에 "멋진 쓰레드", 와 "예쁜 쓰레드"라는 이름을 주고 반복을 100번을 시키자

class ShowThread extends Thread
{
	String threadName;
	
	public ShowThread(String name)
	{
		// super(name); Thread 클래스의 getName 메소드를 통해서 언제든지 문자열의 형태로 참조할 수 있다
		threadName=name;
	}
	
	public void run()
	{
		for(int i=0; i<100; i++)
		{
			System.out.println("안녕하세요. "+threadName+"입니다.");
			try
			{
				sleep(100);
				/*
				sleep은 Thread 클래스의 static 메소드로서, 실행흐름을 일시적으로 멈추는 역할을 한다.
				이 문장에서는 인자로 100을 전달했으니, 이 메소드가 호출되면, 이 부분에서 1/1000*100초간 흐름을 멈추게 된다.
				*/
			}
			catch(InterruptedException e)
			{
				e.printStackTrace();
			}
		}
	}
}

class ThreadUnderstand
{
	public static void main(String[] args)
	{
		ShowThread st1=new ShowThread("멋진 쓰레드");
		ShowThread st2=new ShowThread("예쁜 쓰레드");
		st1.start();
		st2.start();
	}
}

-------------------------------------------------------------------------------------

class ShowThread extends Thread
{
	public ShowThread(String name)
	{
		super(name);
	}
	
	public void run()
	{
		for(int i=0; i<100; i++)
		{
			System.out.println("안녕하세요. "+getName()+"입니다.");
			try
			{
				sleep(100);
			}
			catch(InterruptedException e)
			{
				e.printStackTrace();
			}
		}
	}
}

class ThreadUnderstand
{
	public static void main(String[] args)
	{
		ShowThread st1=new ShowThread("멋진 쓰레드");
		ShowThread st2=new ShowThread("예쁜 쓰레드");
		st1.start();
		st2.start();
	}
}

* 쓰레드의 스케줄링(Scheduling)과 쓰레드의 우선순위 컨트롤
둘 이상의 쓰레드가 생성될 수 있기 때문에, 자바 가상머신은(자바 가상머신의 일부로 존재하는 쓰레드 스케쥴러는) 쓰레드의 실행을 스케줄링(컨트롤) 해야 한다. 스케줄링에 사용되는 알고리즘의 기본원칙은 다음과 같다.

@ 우선순위가 높은 쓰레드의 실행을 우선한다.
@ 동일한 우선순위의 쓰레드가 둘 이상 존재할 때는 CPU의 할당시간을 분배해서 실행한다.

자바의 쓰레드에는 우선순위라는 것이 할당된다. 이는 가상머신에 의해서 우선적으로 실행되어야 하는 쓰레드의 순위를 의미하는 것으로, 가장 높은 우선순위는 정수 10으로, 가장 낮은 우선순위는 정수 1로 표현한다.(따라서 총 10단계의 우선순위가 존재한다). 그리고 이러한 쓰레드의 우선순위는 프로그램상에서 변경 및 확인이 가능하다.

쓰레드의 우선순위를 가져오는 메소드? getPriority()
쓰레드의 우선순위를 설정하는 메소드? setPriority()
쓰레드의 우선순위를 설정할 때 쓰는 상수는?	

Thread.MAX_PRIORITY	10
Thread.NORM_PRIORITY	5
Thread.MIN_PRIORITY	1

쓰레드의 라이프 사이클(Life Cycle)은?

	New ------------ (start 메소드 호출 시)
			| 
			V
			Runnable   	------------------> Blocked
			|		<------------------
			|		(스케쥴러는 Runnable 상태의 쓰레드 중
	Dead <----------- 		 하나를 선택해 실행)
	      (run 메소드 완료 시)

쓰레드가 생성되면 위 그림이 보여주는 네 가지 상태 중 한가지 상태에 있게 된다. 
각각의 상태에 놓이는 시점과 상태가 변경되는 시점을 정리하면 다음과 같다.

* New 상태
쓰레드 클래스가 키워드 new를 통해서 인스턴스화 된 상태를 가리켜 'New 상태'라 한다. 
이 상태에서는 자바 가상머신에 의해 관리가 되는 쓰레드의 상태는 아니다. 
즉 운영체제 입장에서는 쓰레드라 부르기에는 이른 감이 있는 상태다. 그러나 자바에서는 이 상태에서부터 쓰레드라 표현한다.

*Runnable 상태
쓰레드 인스턴스를 대상으로 start 메소드가 호출되면, 해당 쓰레드는 비로소 'Runnable 상태'가 된다. 
이는 모든 실행의 준비를 마치고, 스케줄러에 의해서 선택되어 실행될 수 있기만을 기다리는 상태이다. 
이로써 우리는 start 메소드가 호출된다고 해서 바로 run 메소드가 호출되는 것이 아님을 알 수 있다. 
Runnable 상태에 있다가, 스케줄러에 의해서 실행의 대상으로 선택이 되어야 비로소 run 메소드가 처음 호출이 된다.

*Blocked 상태
실행 중인 쓰레드가 sleep, 또는 join 메소드를 호출하건, CPU의 할당이 필요치 않는 입출력 연산을 하게 되면, 
CPU를 다른 쓰레드에게 양보하고, 본인은 'Blocked 상태'가 된다. Blocked 상태에서는 스케줄러의 선택을 받을 수 없다. 
다시 스케줄러의 선택을 받아서 실행이 되려면, Blcoked 상태에 놓이게 된 원인이 제거되어서, 
Runnable 상태로 돌아와야 한다. 입출력 작업으로 인해서 Blocked 상태가 되었다면, 
입출력 작업이 완료되면서 Runnable 상태가 된다. 그리고 sleep 메소드의 호출로 인해서 
Blocked 상태가 되었다면, sleep 메소드가 반환이 되면서 다시 Runnable 상태가 된다.

*Dead 상태
run 메소드의 실행이 완료되어서 run 메소드를 빠져 나오게 되면, 해당 쓰레드는 'Dead 상태'가 된다. 
그리고 이 상태는 쓰레드의 실행을 위해서 할당 받았던 메모리를 비롯해서 
각종 쓰레드 관련 정보가 완전히 사라지는 상태이다. 
참고로 한번 Dead 상태가 된 쓰레드는 다시 Runnable 상태가 되지 못한다. 
쓰레드의 실행을 위해 필요한 모든 것이 소멸되기 때문이다.


쓰레드의 메모리 구성

쓰레드가 생성되면 가상머신은 쓰레드의 실행을 위한 별도의 메모리 공간을 할당한다. 
그렇다면 이러한 별도의 메모리 공간은 정확히 무엇을 의미하는 것일까?
쓰레드의 가장 큰 역할은 별도의 실행흐름 형성이다. 
그리고 별도의 실행흐름은 메소드의 호출을 통해서 형성된다. 
즉 처음에는 run 메소드가 호출되고, run 메소드 내에서는 또 다른 메소드를 호출하면서 
main 메소드와는 다른 흐름을 형성한다. 이렇듯 main 메소드와는 전혀 다른 실행흐름을 형성하기 위해서는 
별도의 스택이 쓰레드에게 할당되어야 한다. 
따라서 main 쓰레드 이외에 두 개의 쓰레드가 추가로 생성되면, 가상머신은 다음의 형태로 메모리를 구성한다.



		공유			공유
메소드 영역  ----------> 메소드 영역 <---------- 메소드 영역


					
스택 영역  		 스택 영역 		 스택 영역


		공유			공유
힙 영역      ---------->   힙 영역   <---------- 힙 영역

A 쓰레드		main 쓰레드		B 쓰레드


	쓰레드에 할당되는 메모리

위 그림에서 보이듯이 모든 쓰레드는 자신의 스택을 할당 받는다. 
그러나 힙과 메소드 영역은 모든 쓰레드가 공유한다. 
여기서 특히 힙이 공유됨에 주목하자. 힙 영역이 공유된다는 것은 
모든 쓰레드가 동일한 힙 영역에 접근이 가능함을 의미하는 것이고, 이는 다음과 같은 일이 가능함을 의미하는 것이다.
"A 쓰레드가 만든 인스턴스의 참조 값(사실상 주소 값)만 알면 B 쓰레드도 A 쓰레드가 만든 인스턴스에 접근 가능하다."
그래서 쓰레드 사이에 데이터를 주고받아야 할 때에는(쓰레드간 통신이 필요할 때에는) 힙 영역을 활용한다.

참고:
쓰레드 인스턴스를 생성하고 나서, start 메소드를 호출하면 run 메소드가 실행되는데, run 메소드를 직접 호출하면 안되나?
run 메소드를 직접 호출하는 것도 불가능한 일은 아니다. 
단 이러한 경우에는 단순한 메소드의 호출일뿐, 쓰레드의 생성으로 이어지지는 않는다. 
쓰레드는 자신만의 메모리 공간을 할당 받아서 별도의 실행 흐름을 형성한다. 
따라서 자바 가상머신은 start 메소드의 호출을 요구하는 것이다. 
메모리 공간의 할당 등 쓰레드의 실행을 위한 기반을 마련한 다음에 run 메소드를 대신 호출해 주기 위해서 말이다. 
이는 우리가 main 메소드를 직접 호출하지 않는 것과 비슷한 이치이다.

CPU가 하나인데, 어떻게 둘 이상의 쓰레드가 동시에 실행 가능한가?
이 질문에 대한 답변은 생각보다 간단하다. 모든 쓰레드는 CPU를 공유한다. 
물론 CPU를 공유하는 방식에는 원칙이 존재한다. 참고로 코어(CPU 내에 존재하는 연산장치)가 
여러 개 존재하는 CPU에서는 쓰레드 각각에 코어가 하나씩 할당되어 실행되기도 한다.

main 메소드가 종료되어도 쓰레드는 실행을 계속하나? 그리고 쓰레드는 run 메소드의 실행이 완료되면 종료되나?
쓰레드의 main 메소드가 run 메소드이다. 따라서 run 메소드의 실행이 완료되면, 
해당 스레드는 종료가 되고 소멸된다. 그리고 앞서 보인 예제에서는 main 메소드 내에서 쓰레드를 생성했었다. 
그런데 쓰레드를 생성하고, start 메소드를 호출한다고 해서, 
main 메소드가 멈춰서는 것은 아니다. main 메소드도 여느 쓰레드와 마찬가지로 자신만의 실행흐름을 이어간다. 
따라서 main 메소드가 먼저 종료될 수도 있다. 하지만 main 메소드가 종료되어도 실행 중에 있는 쓰레드가 있다면, 
프로그램은 종료되지 않는다. 사실 main 메소드도 쓰레드에 의해 실행된다. 
그리고 main 메소드를 실행하는 쓰레드를 가리켜 별도로 'main 쓰레드'라 부르기도 한다. 
결국 마지막 남은 쓰레드까지 실행을 완료해야 프로그램은 종료된다.

쓰레드가 별도의 실행흐름을 구성하는 것은 알겠는데, 
그렇다면 정확히 무엇을 가리켜 쓰레드라 하나? 인스턴스가 쓰레드인가?
Thread를 상속하는 클래스의 인스턴스를 가리켜 쓰레드라고도 하지만, 
이는 엄밀히 말해서 잘못된 표현이다. 쓰레드는 자바 가상머신이 생성하는 것이기 때문이다. 
start 메소드가 호출되면, 자바 가상머신은 별도의 실행흐름을 형성하기 위한 여러 가지 준비에 들어간다. 
그 중 대표적인 것은 메모리 공간의 할당이다. 
실행흐름을 구성하기 위해서는 메모리 공간의 할당이 필수 아니겠는가? 
그리고 이미 생성된 쓰레드들과 CPU를 나눠 쓰기 위한 각종 정보들이 등록된다. 
이렇듯 별도의 실행흐름을 형성하기 위해서 자바 가상머신에 의해 만들어지는(또는 준비되는) 
모든 리소스와 각종 정보들을 총칭해서 쓰레드라 한다.

4. class Sum 이 있고 여기에는 숫자를 저장할 수 있는 Instance 변수와 
숫자를 더하는 메소드 숫자를 반환하는 메소드가 있다
class AddThread 라는 클래스를 쓰레드를 돌리기 위해서 인터페이스를 구현해서 두 개의 숫자 인스턴스 변수와
이 두개의 숫자 인스턴스 변수를 시작 값부터 끝 값까지 더하도록 메소드를 만들자.
그리고 메인메소드에서 쓰레드를 두 개 생성해서 하나는 1부터 50까지 더하고 
하나는 51부터 100까지 더해서 두 개의 쓰레드 실행결과 그 더한 값을 출력하도록 하자.

* Runnable 인터페이스는 run 메소드 하나로 이뤄져 있다.

class Sum
{
	int num;
	public Sum() { num=0; }
	public void addNum(int n) { num+=n; }
	public int getNum() { return num; }
}

/*
Sum 클래스를 상속하면서 Runnable 인터페이스를 구현하고 있다. 이 인터페이스는 run
메소드 하나로 이뤄져 있다.
*/
class AdderThread extends Sum implements Runnable
{	
	int start, end;
	
	public AdderThread(int s, int e)
	{
		start=s;
		end=e;
	}
	public void run()
	{
		for(int i=start; i<=end; i++)
			addNum(i);
	}
}

class RunnableThread
{
	public static void main(String[] args)
	{
		AdderThread at1=new AdderThread(1, 50);
		AdderThread at2=new AdderThread(51, 100);
		Thread tr1=new Thread(at1);
		Thread tr2=new Thread(at2);
		tr1.start();
		tr2.start();
		// start 메소드의 호출을 통해서 최종으로 쓰레드를 생성 및 실행시키고 있다.		

		try
		{
			tr1.join();
			tr2.join();
			// 쓰레드 인스턴스를 대상으로 join 메소드를 호출하고 있다. 이는 해당 쓰레드가 종료될 때
			// 까지 실행을 멈출 때 호출하는 메소드이다.
		}
		catch(InterruptedException e)
		{
			e.printStackTrace();
		}
		
		System.out.println("1~100까지의 합: "+(at1.getNum()+at2.getNum()));
	}
}

해당 쓰레드가 종료될 때까지 실행을 멈출 때 호출하는 메소드는?  join()