39. 인스턴스의 입출력에 사용되는 (		) 클래스와 (		) 클래스는 사실상 바이트 스트림에 속한다. 그러나 일반적으로 이 둘은 '오브젝트 스트림'으로 구분 짓는 것이 보통이다.
40. 인스턴스의 저장을 위해서는 ObjectOutputStream 클래스에 정의되어 있는 다음 메소드를 호출하면 된다.
41. 인스턴스의 복원을 위해서는 ObjectInputStream 클래스에 정의되어 있는 다음 메소드를 호출하면 된다.
42. 입출력의 대상이 되는 인스턴스의 클래스는 다음 인터페이스를 구현하거나, 다음 인터페이스를 구현하는 클래스를 상속해야 한다. 즉 직간접적으로 다음 인터페이스를 구현해야 한다.
인스턴스가 파일에 저장되는 과정을 가리켜 (		)라 하고, 파일로부터 인스턴스가 복원되는 과정을 가리켜 (		)라 하는데, Serializable 인터페이스는 "이 클래스의 인스턴스는 직렬화를 해도 괜찮습니다." 의 표시를 목적으로 사용된다. 때문에 추가로 정의해야 할 메소드도 존재하지 않는다. 
43. 문제43 폴더에 있는 Circle 클래스를 이용하여 
Circle 인스턴스 new Circle(1, 1, 2.4)와
Circle 인스턴스 new Circle(2, 2, 4.8)을 저장하고
그리고 "String implements Serializable" String 인스턴스를 파일로 저장하고,
다시 파일로 부터 읽어 들이자.

class Circle 
{
	int xPos;
	int yPos;
	double rad;
	
	public Circle(int x, int y, double r)
	{
		xPos=x;
		yPos=y;
		rad=r;
	}
	public void showCircleInfo()
	{
		System.out.printf("[%d, %d] \n", xPos, yPos);
		System.out.println("rad: "+rad);
	}
}


인스턴스의 입출력이 리소스 소모가 많은 작업이다. 때문에 과도한 직렬화는 성능에 영향을 줄 수 있다. 하지만 빈번히, 연속적으로 입출력이 발생하는 상황이 아니라면, 그리고 시스템에 크게 영향을 주지 않는 상황이라면, 직렬화의 적절한 활용은 다양한 상황에서 프로그래머의 수고를 덜어주기도 한다.


44. 43번의 Circle 클래스에 있는 인스턴스 변수 xPos와 yPos를 멤버변수로 하는 Point 클래스로 만들자. 그리고 다음 내용을 수행하자.
Circle 인스턴스 new Circle(1, 1, 2.4)와
Circle 인스턴스 new Circle(2, 2, 4.8)을 저장하고
그리고 "String implements Serializable" String 인스턴스를 파일로 저장하고,
다시 파일로 부터 읽어 들이자.

"직렬화되는 인스턴스의 멤버 변수가 참조하는 인스턴스도 Serializable 인터페이스를 구현한다면, 이 역시도 함께 묶여서 직렬화된다."

	Serializable					Serializable

	--------------------------------			----------------
	|  Point p ---------------------|----------->		| int x		|	
	|  Double rad			|			| int y		|
	---------------------------------			-----------------
	
	Circle							Point



	Serializable		Serializable		Serializable
				
	----------------		----------------	 	----------------
	|  BBB b 	------|---->	   | CCC -------|------>	| int m3	|	
	|  int m1	      |	           | int m2     |		|		|
	-----------------		-----------------		-----------------
	
	AAA			BBB			CCC


45. 직렬화의 대상에서 제외시키겠다면, (		)

문제 45폴더에 있는 Personalnfo 클래스의 String secretInfo와 int secretNum을 직렬화 대상에서 제외시키고 이것을 파일로 출력한 후 다시 입력받아 출력해보자.

46. transient로 선언된 변수는 인스턴스 복원 시 어떠한 값으로 초기화되는가?
47. 다음과 같은 특징을 갖는 스트림 클래스는? 
* 입력과 출력이 동시에 이뤄질 수 있다.
* 입출력 위치를 임의로 변경할 수 있다.
* 파일을 대상으로만 존재하는 스트림이다.

48. 47에서 말하는 클래스의 대표적인 입력 메소드는?

*
* 
* 
* 

49. 47에서 말하는 클래스의 대표적인 출력 메소드는?

* 
* 
* 
* 

50. 47에서 말하는 클래스의 현재의 입출력 위치를 확인하거나 변경할 수 있는 메소드는?

* 
* 

위치 정보는 getFilePointer 메소드의 호출을 통해서 확인이 가능하다. 반면 seek 메소드의 호출을 통해서 입출력의 위치도 변경할 수도 있다.

51. 47에서 말하는 클래스의 생성자에 대해서 설명하시오.

52. data.bin 파일을 읽고 쓰기 모드로 열고
파일의 위치를 출력
정수 200 파일에 출력
정수 500 파일에 출력
파일의 위치를 출력
실수 48.65를 파일에 출력
실수 52.24를 파일에 출력
파일의 위치를 출력
위치를 맨 처음으로 이동
파일의 위치를 출력
파일로부터 정수 200과 500을 입력받아 모니터에 출력
파일의 위치를 출력
파일로부터 실수 48.65과 52.24를 입력받아 입력받아 출력
파일의 위치를 출력

53. [마지막에 저장된 데이터 Read!]
52번에서 생성한 파일의 마지막에는 8바이트 double형 데이터가 저장되어 있다. 파일을 열어서 이 부분의 데이터만 읽어서 출력하는 프로그램을 작성해 보자. 참고로 RandomAccessFile 클래스에 정의되어 있는 다음의 메소드를 활용하면 보다 쉽게 문제를 해결할 수 있다.
public long length() throws IOException
