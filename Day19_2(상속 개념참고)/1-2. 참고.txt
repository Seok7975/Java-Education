* 객체지향 패러다임은 재활용의 관점에서 실패한 패러다임이다.
* 재활용할 수 있다는 이유만으로 상속을 사용하면 안된다.
  상속을 통해 연관된 일련의 클래스에 대한 공통적인 규약을 정의할 수 있다.
* 이전에 개발해 놓은 클래스의 재활용을 보인 사례는 매우 드물다. 즉 상속은 재활용의 측면에서 바라보면 별로 매력적이지 않다! 그리고 재활용에 대한 이슈는 객체지향 패러다임에서 CBD(Component Based Development)라는 패러다임으로 옮겨 간지 오래이다.

* 객체지향이 재활용의 관점에서 실패한 이유는
 객체지향에서 언급하는 재활용은 클래스 단위의 재활용이다. 그런데 이는 다음과 같은 문제점을 안고 있다.
 @ 클래스 하나를 재활용하는 것이 새롭게 디자인하는 것보다 더 큰 노력이 든다.
 @ 재활용을 고려해서 클래스를 디자인할 경우, 설계에 필요한 시간이 몇 배 더 길어진다.

* 상속 관계에 있어서 상속을 받은 클래스를 가리켜 '하위 클래스(sub class)' 또는 '유도 클래스(derived class)'라 부르고, 상속의 대상이 된 클래스를 가리켜 '상위 클래스(super class)' 또는 '기초 클래스(base class)라 부른다.
* 하위 클래스의 생성자에서는 제일 먼저 상위 클래스의 생성자를 호출해야 한다.

다음 인스턴스 변수에 별도의 초기화를 진행하지 않으면, 어떤 값으로 초기화가 되는가?
자료형			디폴트 값
int			0
long			0
double			0
boolean			false
String(or any object)		null

* 하위 클래스의 생성자 내에서는 반드시 상위 클래스의 생성자가 호출되어야 한다. 만약에 상위 클래스의 생성자를 호출할 수 없는 구조로 하위 클래스의 생성자가 정의된다면, 하위클래스의 인스턴스 생성은 불가능하다.

class AAA
{
	int num1;		// AAA() {} 디폴트 생성자가 자동으로 삽입
}

class BBB extends AAA
{
	int num2;		// BBB() { super(); } 디폴트 생성자가 자동으로 삽입
}

========================================

class AAA
{
	int num1;
}

class BBB extends AAA
{
	int num2;
	BBB() 
	{ 
		num2 = 0; 
	}
}


/*
위에 BBB 클래스는 super() 자동삽입
하위 클래스의 생성자 내에 super문이 보이지 않으면, 인자를 전달받지 않는 상위 클래스의 생성자 호출을 위한 super문이 자동으로 삽입된다.
class BBB extends AAA
{
	int num2;
	BBB() 
	{ 
		super();		// 자동으로 삽입된 super!
		num2 = 0; 
	}
}	
*/

==============================================
class AAA
{
	int num1;
	protected int num2;
}

class BBB extends AAA
{
	BBB()
	{
		num1 = 10;	// AAA 클래스의 default 멤버에 접근. AAA클래스와 BBB 클래스는 default패키지라는 하나의 패키로 묶이기 때문
		num2 = 20;	// BBB 클래스의 protected 멤버에 접근. protected는 "다른 패키지에 존재할지라도 상속관계에 놓이면 접근을 허용하는 접근제어 지시자"이다.
	}
}

* private 멤버도 상속이 된다. 그러나 간접적으로 접근해야 한다.
* 메소드 오버라이딩을 할 때 접근제어지시자는 넓혀지는 형태로는 할 수 있어도 좁혀지는 형태로는 할 수 없다.

* UI(User Interface)
UI란 프로그램 사용자의 입력을 받아들이고, 프로그램의 출력을 표현하기 위한 화면을 의미한다. 자바에서는 이러한 화면의 디자인을 위한 클래스들을 AWT 그리고 SWING 이라는 패키지를 통해서 제공하고 있다.

* 상속을 통해 연관된 일련의 클래스에 대한 공통적인 규약을 정의할 수 있습니다.

* 모든 클래스가 상속하는 클래스는? Object
 클래스를 정의할 때 다른 어떤 클래스도 상속하지 않으면(키워드 extends를 사용하지 않으면), 해당 클래스는 java.lang 패키지에 묶여있는 Object 클래스를 상속하게 된다. 즉 다음의 클래스 정의는
class MyClass { . . . }
다음의 클래스 정의와 차이가 없다.
class MyClass extends Object { . . . }

이렇듯  모든 클래스는 직접적으로 혹은 간접적으로 Object 클래스를 상속하게 되어 있다. 따라서 다음과 같은 코드의 구성이 가능하다.
Object obj1 = new MyClass();
Object obj2 = new int[5];	// 배열도 인스턴스이므로

Object 클래스를 상속하도록 한 이유는 무엇일까? 이는 자바의 모든 인스턴스에 공통된 기준을 적용하기 위함이다.

Object 클래스에는 다음의 메소드가 정의되어 있다.
public String toString() { . . . }
System.out.println은 오버로딩(오버라이딩 아니다) 되어있는 메소드인데, 그 중 하나가 다음과 같이 정의되어 있기 때문에 어떠한 클래스의 인스턴스이건 인자로 전달될 수 있는 것이다.
public void println(Object x)
@ 모든 인스턴스는(인스턴스의 참조 값은) System.out.println의 인자로 전달될 수 있다.
@ 인자로 전달되면, 해당 인스턴스의 toString 메소드가 호출되면서 반환되는 문자열이 출력된다.

기본적으로 오버라이딩 해 두면 좋은 toString 메소드
자바의 API 문서에서는 toString 메소드에 대해서 다음과 같이 언급하고 있다.

@ toString 메소드는 인스턴스의 정보를 문자열의 형태로 반환하기 위한 메소드이다.
@ 가급적이면 toString 메소드를 오버라이딩을 해서 인스턴스에 대한 정보를 적절히 표현할 수 있도록 하는 것이 좋다.

* AAA 클래스를 상속하는 것을 허용하지 않을려면 어떡해야 하는가?
final class AAA
{
	. . .
}
대표적인 final 클래스로는 String 클래스가 있다.

* void func(int n) { ... } 라는 메소드를 더 이상 메소드 오버라이딩 하지 않을려면 어떡해야 하는가?
final void func(int n) { . . .}
대표적인 final 메소드로는 Object 클래스의 wait ,notify, notifyall 메소드 등이 있다.
